Project 2 Report - Elvis Rodrigues

LINKED LIST IMPLEMENTATION
The linked list used here is a circular doubly-linked list with no dummy node. A head pointer is used to keep track of the list. The nodes contain a placeholder for a value (m_data), and two pointers to the next and previous node (m_next and m_prev).
An empty Set with no node would have its head pointer `m_head` set to nullptr and size to zero.
A single element would have next and previous pointers both pointing to itself.
The nodes of a Set are arranged in ascending order of the nodes' values `m_data`, with the "smallest" node as the head node i.e. in the order 0 < 3 < 4 < 9 < 12 for example, with the head pointer at node '0'.

PSEUDO-CODE

- insert(`val`):
if Set is empty:
  create new node. Assign pointer to head.
  return true
if Set contains `val`
  return false
create new node with `val`
repeatedly:
  if `val` < value of current node
    change new node's next and prev pointers to current and previous nodes.
    change previous node next ptr to new node
    change current node prev ptr to new node
    return true
set node to previous node // Since the current node is currently head node.
insert item as described in loop.
return true

- erase(`val`):
if Set not contain `val`
  return false
if node size is 1 and node of `val` the head
  delete node and set head to null-pointer
  return true
else if node of `val` the head
  set head pointer to node next to current head node
delete node containing `val` and rearrange pointers
reduce size by 1
return true

- unite(s1, s2, result):
// get function has logic for empty Sets
copy s1 into ts1, temporary Set
copy s2 into ts2, temporary Set // Aliasing
erase all elements of result if it is non-empty
repeatedly:
  insert elements of ts1 into result
repeatedly:
  insert elements of ts2 into result
// In second insertion, insert() has logic to check for duplicates.

- subtract(s1, s2, result):
// get function has logic for empty Sets
copy s1 into ts1, temporary Set
copy s2 into ts2, temporary Set // Aliasing
erase all elements of result if it is non-empty
repeatedly through s1:
  if value of s1 not in s2:
    insert value in result

TESTS:
NOTE: These tests were done for ItemType = unsigned long

Set a; // default constructor
a.insert(5); // testing insertions
a.insert(2);
a.insert(6);
a.insert(4); // insertions in random order
ItemType val;
assert(a.size() == 4 && !(a.empty()));
a.get(0, val);
assert(val == 2);
a.get(1, val);
assert(val == 4);
a.get(2, val);
assert(val == 5);
a.get(3, val);
assert(val == 6); // ascending order test

Set b;
b.insert(25);
b.insert(2);
b.insert(6);
b.insert(420);
assert(!b.insert(6)); // testing duplicate entry
b.insert(1);

assert(b.size() == 5 && !(b.empty())); // duplicate entry
b.get(4, val); assert(val == 420);

assert(!(b.get(6, val)) && val == 420); // Out of bounds fetch

Set bah;
assert(bah.empty()); // empty check
assert(!bah.erase(69)); // erasing with an empty Set
assert(!(a.erase(7))); // value not in a
assert(a.erase(6)); // erase function
assert(!(a.get(3, val)) && val == 420); // last value missing
assert(b.erase(1)); // erasing head node
assert(b.get(0, val) && val == 2); // correct head placement

a.swap(b); // swap function
b.get(0, val);
assert(val == 2);
b.get(1, val);
assert(val == 4);
b.get(2, val);
assert(val == 5);
assert(b.size() == 3 && a.size() == 4); // tests for swap
b.swap(a);

a.get(0, val);
assert(val == 2);
a.get(1, val);
assert(val == 4);
a.get(2, val);
assert(val == 5); // check a back to original

Set c = b; // copy constructor
assert(c.size() == 4); // check c size
c.get(0, val);
assert(val == 2);
c.get(1, val);
assert(val == 6);
c.get(2, val);
assert(val == 25);
c.get(3, val);
assert(val == 420);

c = a; // Assignment operator
assert(c.size() == 3);
c.get(0, val);
assert(val == 2);
c.get(1, val);
assert(val == 4);
c.get(2, val);
assert(val == 5);

Set res;
unite(a, b, res);
assert(res.size() == 6);
res.get(0, val); // check res and ordering for unite
assert(val == 2);
res.get(1, val);
assert(val == 4);
res.get(2, val);
assert(val == 5);
res.get(3, val);
assert(val == 6);
res.get(4, val);
assert(val == 25);
res.get(5, val);
assert(val == 420);

subtract(a, b, res);
assert(res.size() == 2);
res.get(0, val); // check res and ordering for subtract
assert(val == 4);
res.get(1, val);
assert(val == 5);

unite(a, b, a); // aliasing in unite
assert(a.size() == 6);
a.get(0, val); // check res and ordering for unite
assert(val == 2);
a.get(1, val);
assert(val == 4);
a.get(2, val);
assert(val == 5);
a.get(3, val);
assert(val == 6);
a.get(4, val);
assert(val == 25);
a.get(5, val);
assert(val == 420);
